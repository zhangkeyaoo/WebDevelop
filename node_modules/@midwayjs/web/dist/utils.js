"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeAgentApplicationContext = exports.getCurrentDateString = exports.findLernaRoot = exports.parseNormalDir = void 0;
const path_1 = require("path");
const find_up_1 = require("find-up");
const fs_1 = require("fs");
const core_1 = require("@midwayjs/core");
const core_2 = require("@midwayjs/core");
const web_1 = require("./framework/web");
const util_1 = require("util");
const interface_1 = require("./interface");
const debug = (0, util_1.debuglog)('midway:debug');
const parseNormalDir = (baseDir, isTypescript = true) => {
    if (isTypescript) {
        // 这里要么就是 src 目录，要么就已经是根目录
        if (!(0, fs_1.existsSync)((0, path_1.join)(baseDir, 'package.json'))) {
            baseDir = (0, path_1.basename)(baseDir);
        }
        const isTypeScriptEnv = (0, core_1.isTypeScriptEnvironment)();
        if (isTypeScriptEnv) {
            return {
                baseDir: (0, path_1.join)(baseDir, process.env.MIDWAY_SOURCE_DIR || 'src'),
                appDir: baseDir,
            };
        }
        else {
            return {
                baseDir: (0, path_1.join)(baseDir, process.env.MIDWAY_SOURCE_DIR || 'dist'),
                appDir: baseDir,
            };
        }
    }
    else {
        // js baseDir
        return {
            baseDir,
            appDir: baseDir,
        };
    }
};
exports.parseNormalDir = parseNormalDir;
const findLernaRoot = (findRoot = process.cwd()) => {
    const userHome = process.env.HOME;
    return (0, find_up_1.sync)(directory => {
        if (find_up_1.sync.exists((0, path_1.join)(directory, 'lerna.json'))) {
            return directory;
        }
        if (directory === userHome) {
            return find_up_1.stop;
        }
    }, { cwd: findRoot, type: 'directory' });
};
exports.findLernaRoot = findLernaRoot;
const getCurrentDateString = (timestamp = Date.now()) => {
    const d = new Date(timestamp);
    return `${d.getFullYear()}-${(d.getMonth() + 1)
        .toString()
        .padStart(2, '0')}-${d.getDate().toString().padStart(2, '0')}`;
};
exports.getCurrentDateString = getCurrentDateString;
async function initializeAgentApplicationContext(agent) {
    const applicationContext = (0, core_1.getCurrentApplicationContext)();
    const agentFramework = new web_1.MidwayWebFramework(applicationContext);
    agentFramework['logger'] = agent.coreLogger;
    agentFramework['appLogger'] = agent.logger;
    agentFramework.app = agent;
    agentFramework.configService = applicationContext.get(core_1.MidwayConfigService);
    agentFramework.environmentService = applicationContext.get(core_1.MidwayEnvironmentService);
    agentFramework.loggerService = applicationContext.get(core_1.MidwayLoggerService);
    agentFramework.informationService = applicationContext.get(core_1.MidwayInformationService);
    agentFramework.overwriteApplication('agent');
    // init decorator service
    const decoratorService = (0, core_1.getCurrentApplicationContext)().get(core_1.MidwayDecoratorService);
    // register @Logger decorator handler
    decoratorService.registerPropertyHandler(interface_1.EGG_AGENT_APP_KEY, (propertyName, meta) => {
        return agent;
    });
    if (process.env['EGG_CLUSTER_MODE'] === 'true') {
        // init aop support
        const aspectService = (0, core_1.getCurrentApplicationContext)().get(core_1.MidwayAspectService);
        const configService = (0, core_1.getCurrentApplicationContext)().get(core_1.MidwayConfigService);
        const loggerService = (0, core_1.getCurrentApplicationContext)().get(core_1.MidwayLoggerService);
        // framework/config/plugin/logger/app decorator support
        // register base config hook
        decoratorService.registerPropertyHandler(core_2.CONFIG_KEY, (propertyName, meta) => {
            var _a;
            if (meta.identifier === core_2.ALL) {
                return configService.getConfiguration();
            }
            else {
                return configService.getConfiguration((_a = meta.identifier) !== null && _a !== void 0 ? _a : propertyName);
            }
        });
        // register @Logger decorator handler
        decoratorService.registerPropertyHandler(core_2.LOGGER_KEY, (propertyName, meta) => {
            var _a;
            return loggerService.getLogger((_a = meta.identifier) !== null && _a !== void 0 ? _a : propertyName);
        });
        decoratorService.registerPropertyHandler(core_2.PIPELINE_IDENTIFIER, (key, meta, instance) => {
            var _a, _b;
            return new core_1.MidwayPipelineService((_b = (_a = instance[core_1.REQUEST_OBJ_CTX_KEY]) === null || _a === void 0 ? void 0 : _a.requestContext) !== null && _b !== void 0 ? _b : this.applicationContext, meta.valves);
        });
        // register @App decorator handler
        decoratorService.registerPropertyHandler(core_2.APPLICATION_KEY, (propertyName, mete) => {
            return agent;
        });
        decoratorService.registerPropertyHandler(core_2.PLUGIN_KEY, (key, target) => {
            return agent[key];
        });
        // init aspect module
        await aspectService.loadAspect();
        debug('[egg]: added extra for "initializeAgentApplicationContext" in cluster mode');
    }
    else {
        debug('[egg]: "initializeAgentApplicationContext" ignore re-init in single process');
    }
    return applicationContext;
}
exports.initializeAgentApplicationContext = initializeAgentApplicationContext;
//# sourceMappingURL=utils.js.map