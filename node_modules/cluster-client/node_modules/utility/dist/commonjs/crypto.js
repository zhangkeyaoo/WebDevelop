"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64decode = exports.base64encode = exports.hmac = exports.sha512 = exports.sha256 = exports.sha1 = exports.md5 = exports.hash = void 0;
const node_crypto_1 = require("node:crypto");
const node_crypto_2 = __importDefault(require("node:crypto"));
const nativeHash = 'hash' in node_crypto_2.default ? node_crypto_2.default.hash : null;
/**
 * hash
 *
 * @param {String} method hash method, e.g.: 'md5', 'sha1'
 * @param {String|Buffer|ArrayBuffer|TypedArray|DataView|Object} s input value
 * @param {String} [format] output string format, could be 'hex' or 'base64'. default is 'hex'.
 * @return {String} md5 hash string
 * @public
 */
function hash(method, s, format) {
    if (s instanceof ArrayBuffer) {
        s = Buffer.from(s);
    }
    const isBuffer = Buffer.isBuffer(s) || ArrayBuffer.isView(s);
    if (!isBuffer && typeof s === 'object') {
        s = JSON.stringify(sortObject(s));
    }
    if (nativeHash) {
        // try to use crypto.hash first
        // https://nodejs.org/en/blog/release/v21.7.0#crypto-implement-cryptohash
        return nativeHash(method, s, format);
    }
    const sum = (0, node_crypto_1.createHash)(method);
    sum.update(s, isBuffer ? 'binary' : 'utf8');
    return sum.digest(format || 'hex');
}
exports.hash = hash;
/**
 * md5 hash
 *
 * @param {String|Buffer|Object} s input value
 * @param {String} [format] output string format, could be 'hex' or 'base64'. default is 'hex'.
 * @return {String} md5 hash string
 * @public
 */
function md5(s, format) {
    return hash('md5', s, format);
}
exports.md5 = md5;
/**
 * sha1 hash
 *
 * @param {String|Buffer|Object} s input value
 * @param {String} [format] output string format, could be 'hex' or 'base64'. default is 'hex'.
 * @return {String} sha1 hash string
 * @public
 */
function sha1(s, format) {
    return hash('sha1', s, format);
}
exports.sha1 = sha1;
/**
 * sha256 hash
 *
 * @param {String|Buffer|Object} s input value
 * @param {String} [format] output string format, could be 'hex' or 'base64'. default is 'hex'.
 * @return {String} sha256 hash string
 * @public
 */
function sha256(s, format) {
    return hash('sha256', s, format);
}
exports.sha256 = sha256;
/**
 * sha512 hash
 *
 * @param {String|Buffer|Object} s input value
 * @param {String} [format] output string format, could be 'hex' or 'base64'. default is 'hex'.
 * @return {String} sha512 hash string
 * @public
 */
function sha512(s, format) {
    return hash('sha512', s, format);
}
exports.sha512 = sha512;
/**
 * HMAC algorithm.
 *
 * Equal bash:
 *
 * ```bash
 * $ echo -n "$data" | openssl dgst -binary -$algorithm -hmac "$key" | openssl $encoding
 * ```
 *
 * @param {String} algorithm dependent on the available algorithms supported by the version of OpenSSL on the platform.
 *   Examples are 'sha1', 'md5', 'sha256', 'sha512', etc.
 *   On recent releases, `openssl list-message-digest-algorithms` will display the available digest algorithms.
 * @param {String} key the hmac key to be used.
 * @param {String|Buffer} data content string.
 * @param {String} [encoding='base64'] default encoding is base64
 * @return {String} digest string.
 */
function hmac(algorithm, key, data, encoding) {
    encoding = encoding || 'base64';
    const hmac = (0, node_crypto_1.createHmac)(algorithm, key);
    hmac.update(data, Buffer.isBuffer(data) ? 'binary' : 'utf8');
    return hmac.digest(encoding);
}
exports.hmac = hmac;
/**
 * Base64 encode string.
 *
 * @param {String|Buffer} s input value
 * @param {Boolean} [urlSafe=false] Encode string s using a URL-safe alphabet,
 *   which substitutes - instead of + and _ instead of / in the standard Base64 alphabet.
 * @return {String} base64 encode format string.
 */
function base64encode(s, urlSafe) {
    if (!Buffer.isBuffer(s)) {
        s = Buffer.from(s);
    }
    let encode = s.toString('base64');
    if (urlSafe) {
        encode = encode.replace(/\+/g, '-').replace(/\//g, '_');
    }
    return encode;
}
exports.base64encode = base64encode;
/**
 * Base64 string decode.
 *
 * @param {String} encodeStr base64 encoding string.
 * @param {Boolean} [urlSafe=false] Decode string s using a URL-safe alphabet,
 *   which substitutes - instead of + and _ instead of / in the standard Base64 alphabet.
 * @param {encoding} [encoding=utf8] if encoding = buffer, will return Buffer instance
 * @return {String|Buffer} plain text.
 */
function base64decode(encodeStr, urlSafe, encoding) {
    if (urlSafe) {
        encodeStr = encodeStr.replace(/\-/g, '+').replace(/_/g, '/');
    }
    const buf = Buffer.from(encodeStr, 'base64');
    if (encoding === 'buffer') {
        return buf;
    }
    return buf.toString(encoding || 'utf8');
}
exports.base64decode = base64decode;
function sortObject(o) {
    if (!o || Array.isArray(o) || typeof o !== 'object') {
        return o;
    }
    const keys = Object.keys(o);
    keys.sort();
    const values = [];
    for (const k of keys) {
        values.push([k, sortObject(o[k])]);
    }
    return values;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NyeXB0by50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSw2Q0FBMkU7QUFDM0UsOERBQWlDO0FBS2pDLE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBSSxxQkFBTSxDQUFDLENBQUMsQ0FBQyxxQkFBTSxDQUFDLElBQWtCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUV2RTs7Ozs7Ozs7R0FRRztBQUNILFNBQWdCLElBQUksQ0FBQyxNQUFjLEVBQUUsQ0FBWSxFQUFFLE1BQTZCO0lBQzlFLElBQUksQ0FBQyxZQUFZLFdBQVcsRUFBRSxDQUFDO1FBQzdCLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFDRCxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0QsSUFBSSxDQUFDLFFBQVEsSUFBSSxPQUFPLENBQUMsS0FBSyxRQUFRLEVBQUUsQ0FBQztRQUN2QyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQsSUFBSSxVQUFVLEVBQUUsQ0FBQztRQUNmLCtCQUErQjtRQUMvQix5RUFBeUU7UUFDekUsT0FBTyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQsTUFBTSxHQUFHLEdBQUcsSUFBQSx3QkFBVSxFQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQy9CLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBVyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN0RCxPQUFPLEdBQUcsQ0FBQyxNQUFN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